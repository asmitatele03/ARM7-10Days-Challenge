ðŸ“˜ LCD 4-Bit Driver â€“ Bidirectional Character Scrolling (A â†’ Z Movement Demo)

This project demonstrates how to control a 16Ã—2 LCD in 4-bit mode using an embedded microcontroller.
The program creates a visually appealing animation where:

The character â€˜Aâ€™ moves from left to right on the first row, and

The character â€˜Zâ€™ moves from right to left on the second row.


Both characters move simultaneously in opposite directions, creating a mirrored scrolling effect.
This is a simple and effective demonstration of LCD addressing, cursor control, and timed display updates.

ðŸ§© Understanding the Code

1. LCD Initialization

The first step is to initialize the LCD:

lcd_init();

This function configures the LCD in 4-bit communication mode, sets up display settings, and prepares it to receive commands and data.
Without proper initialization, the LCD will not respond to commands correctly.

2. Infinite Animation Loop

The animation runs inside:

while(1)

This ensures that the scrolling effect continues endlessly until the system is powered off or reset.

3. Main Animation Logic

A for loop is used to iterate through all 16 columns of the LCD:

for(i = 0; i < 16; i++)

Since a 16Ã—2 LCD has 16 characters per row, this loop covers every possible position.


---

4. Moving Character â€˜Aâ€™ on Row 1

To display 'A' moving from left â†’ right, the cursor is positioned using:

lcd_cmd(0x80 + i);
lcd_data('A');

Explanation:

0x80 is the starting DDRAM address of Row 1.

Adding i shifts the cursor one position on each iteration.

lcd_data('A') prints the letter at the new position.


This results in 'A' moving smoothly from column 0 to column 15.


---

5. Moving Character â€˜Zâ€™ on Row 2

To make 'Z' move right â†’ left, the cursor is positioned using:

lcd_cmd(0xC0 + (15 - i));
lcd_data('Z');

Explanation:

0xC0 is the starting address of Row 2.

(15 - i) makes the character start from the rightmost column and move backward.

This creates a reverse-scrolling effect.



---

6. Delay and Screen Refresh

Each frame is paused for half a second:

delay_ms(500);

This makes the motion visible and smooth.

After printing each animation frame, the display is cleared:

lcd_cmd(0x01);

Clearing the LCD ensures that only the current frame is visible and removes any previous characters left behind.


---

ðŸŽ¥ Final Output Effect

âœ¨ 'A' moves from left to right on the first row.
âœ¨ 'Z' moves from right to left on the second row.
âœ¨ Both characters move simultaneously, creating a mirrored scrolling animation.
âœ¨ The screen clears between frames, ensuring a neat and clean movement.

This demonstration is perfect for understanding:

DDRAM addressing in LCDs

Cursor positioning

4-bit data transfer

Display refresh techniques

Simple animation logic in embedded systems



---

If you want, I can also create: âœ… A proper README.md format
âœ… A GitHub description
âœ… A block diagram
âœ… A flowchart
Just tell me!
